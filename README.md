# LC Resonator Locator and Digitizer

![20251022_191501316](https://github.com/user-attachments/assets/f66b20c2-2141-47fd-8747-2fe812d9bd32)

## Second Year Group Project Hardware Element

This project is the hardware input element of my second year FPGA group project. 
The FPGA part was a hardware accelerated complex function plotter, taking coordinates of poles and zeros on the complex plane as inputs and displaying the result on an HDMI display.
The input hardware is a board that detects the positions of tokens that represent poles and zeros of different orders which can be placed on the board.

## Theory of Operation

![20250601_212948976](https://github.com/user-attachments/assets/b1e17413-b9ff-4efe-a226-938dd5f9d043)

The tokens are a capacitor and inductor in paralell, forming an LC resonator. The inductor is unshielded, allowing it to interact with external magnetic fields. 
They can be caused to resonate by an electromagnetic impulse generated by placing it on a coil and sending a pusle of current through it. 
The presence of the token can be detected by measuring the voltage on the coil after the original impulse and looking for the resonant frequency of the resonator.

Using this for detection and location of the tokens can be done by separating and multiplexing the detection loops into transmission and reception loops.
These loops can be elongated and placed perpendicularly on opposite sides of a PCB. Pulsing one Tx loop and listening on all Rx loops measures token presence on one row and scanning all Tx coils reveals the entire plane.

Measurement of tokens not located exactly within one intersection (cell) of Tx and Rx coils is done by measuring the amplitude of a cluster of responses and adjusting the final position proportionally. 
This requires the minimum spacing between tokens to be greater than twice the width of the coils.

Differentiating between types of tokens, representing differing orders of the poles and zeros, is done by varying the resonant frequencies of the tokens and measuring this in the response.

## Issues and Reflections

This project was designed with little time for development and refinement. The PCB had to be ordered within 2 weeks of the project start, with no second revision. This means there are some (very questionable) quirks in the design, including:
- "Row Amplifers": After some debate, we did not want to risk the expected sub-millivolt signal being lost in the multiplexers. To be safe, we added a 20dB amplifier for every row.
  Not only was the signal much larger than measured in the prototype, but the multiplexers do not affect the signal in a meaningful way. The capacitor between the gain-setting resistors and the reference is not necessary and nor is the entire row amplifier circuit.
  This saves 8 ICs, lots of board space and some cost.

- Slow loop driver ICs: The loop driver ICs are pulsed by pulsing their sleep pins, not the input pins. We did not read the datasheet properly - these ICs take 30µs to wake from sleep.
  Given this needs to be done 128 times per scan, at multiple scans per second, this is a big limiting factor in the update rate.
  Instead, the sleep pins should be tied low and the OE pins on the shift registers be pulsed instead.

- Slow OLED: The oled is of the I2C variety, running at 400kHz. Using a non-DMA library to drive it, this is very slow and stops the UI task from properly reading the rotary encoder inputs.

- Suicidal power managment: If there is a glitch in the power supply, it seems to be possible that the shift registers and driver ICs can be set to drive a loop, shorting the supply to ground and browning out the µC and preventing it from turning off the drivers.
  This does not cause damage to the board, but the power needs to be recycled before it will work again and is very annoying.

- Substandard firmware: The firmware became progressivly more rushed as time went on. This is especially visible in the liberal use of ```nop``` delays instead of proper freeRTOS and timer delays.
